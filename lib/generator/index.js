'use strict';

const _ = require('lodash');
const Transformer = require('./transformer');
const getDataType = require('./get-data-type');

function getReturnType(operation) {
    if (!operation.responses) {
        return 'any';
    }

    let typeCount = 0;
    let returnType = '';
    for (let statusKey in operation.responses) {
        if (!operation.responses[statusKey].dataType) {
            continue;
        }
        typeCount++;
        if (returnType) {
            returnType += ' | ';
        }
        returnType += getDataType(operation.responses[statusKey].dataType);
    }
    if (!returnType) {
        return 'any';
    }
    return typeCount > 1 ? `(${returnType})` : returnType;
}

function getMethodSignature(operationName, operation) {
    let parameters = '';
    for (let p = 0; p < (operation.parameters || []).length; p++) {
        let parameter = operation.parameters[p];
        if (parameters) {
            parameters += ', '
        }
        parameters += `${parameter.name}: ${getDataType(parameter.dataType, parameter.name)}`;
    }

    let returnType = getReturnType(operation);

    let methodSig = `${operationName}(${parameters}): Observable<${returnType}>`;
    return methodSig;
}

module.exports = class Generator {
    constructor(definition, profile) {
        this.definition = definition;
        this.profile = profile;
        this.transform = new Transformer(profile);
    }

    generate() {
        this.code = this.generateInitialCode();
        this.code.push('');
        this.generateServices();
        this.code.push('');
        this.generateModels();
        this.code.push('');
        this.generateEnums();
        return this.code.join(require('os').EOL);
    }

    generateInitialCode() {
        let code = [
            `//------------------------------`,
            `// <auto-generated>`,
            `//     Generated using the swagen tool`,
            `// </auto-generated>`,
            `//------------------------------`,
        ];

        if (this.definition.metadata.title) {
            code.push(`// ${this.definition.metadata.title}`);
        }
        if (this.definition.metadata.description) {
            code.push(`// ${this.definition.metadata.description}`);
        }
        if (this.definition.metadata.baseUrl) {
            code.push(`// Base URL: ${this.definition.metadata.baseUrl}`);
        }

        code.push(
            ``,
            `import 'rxjs/Rx';`,
            `import { Observable } from 'rxjs/Observable';`,
            `import { Injectable, Inject, Optional, OpaqueToken } from '@angular/core';`,
            `import { Http, Headers, Response, RequestOptionsArgs } from '@angular/http';`
        );

        return code;
    }

    generateServices() {
        for (let serviceName in this.definition.services) {
            let service = this.definition.services[serviceName];
            this.generateInterface(serviceName, service);
            this.code.push('');
            this.generateImplementation(serviceName, service);
            this.code.push('');
        }
        this.generateBuildUrlFunction();
        this.code.push('');
        this.generateHandleErrorFunction();
    }

    generateInterface(serviceName, service) {
        let transformedServiceName = this.transform.serviceName(serviceName, {
            service: service
        });
        this.code.push(`export interface I${transformedServiceName}Client {`);
        for (let operationName in service) {
            let operation = service[operationName];
            let transformedOperationName = this.transform.operationName(operationName, {
                serviceName: serviceName,
                service: service
            });
            this.code.push(`    ${getMethodSignature(transformedOperationName, operation)};`)
        }
        this.code.push('}');
    }

    generateImplementation(serviceName, service) {
        let transformedServiceName = this.transform.serviceName(serviceName, {
            service: service
        });
        let baseUrl = this.profile.options.baseUrl;
        let baseUrlVariable = baseUrl.variable || _.camelCase(baseUrl.provider);
        let baseUrlPath = baseUrl.path ? baseUrlVariable + '.' + baseUrl.path.join('.') : baseUrlVariable;
        this.code.push(
            `@Injectable()`,
            `export class ${transformedServiceName}Client implements I${transformedServiceName}Client {`,
            `    private baseUrl: string;`,
            ``,
            `    constructor(`,
            `        @Inject(Http) private http: Http,`,
            `        @Optional @Inject(${baseUrl.provider}) ${baseUrlVariable}?: ${baseUrl.provider}`,
            `    ) {`,
            `        this.baseUrl = ${baseUrlPath};`,
            `    }`,
            ``
        );

        for (let operationName in service) {
            let operation = service[operationName];
            let transformedOperationName = this.transform.operationName(operationName, {
                serviceName: serviceName,
                service: service
            });

            this.code.push(
                `    /**`,
                `     * ${operation.description || '<No description>'}`,
                `     */`,
                `    public ${getMethodSignature(transformedOperationName, operation)} {`
            );

            let requiredParams = (operation.parameters || []).filter(p => !!p.required);
            for (let i = 0; i < requiredParams.length; i++) {
                let requiredParam = requiredParams[i];
                this.code.push(
                    `        if (${requiredParam.name} == undefined || ${requiredParam.name} == null) {`,
                    `            throw 'The parameter \\'${requiredParam.name}\\' must be defined.';`,
                    `        }`
                )
            }

            let pathParams = (operation.parameters || []).filter(p => p.type === 'path');
            let hasPathParams = pathParams.length > 0;
            this.code.push(`        let resourceUrl: string = '${operation.path}'${hasPathParams ? '' : ';'}`);
            for (let i = 0; i < pathParams.length; i++) {
                let isLastParam = i === pathParams.length - 1;
                this.code.push(`            .replace('{${pathParams[i].name}}', encodeURIComponent('' + ${pathParams[i].name}))${isLastParam ? ';' : ''}`);
            }

            let queryParams = (operation.parameters || []).filter(p => p.type === 'query');
            let hasQueryParams = queryParams.length > 0;
            if (hasQueryParams) {
                this.code.push(`        let queryParams: {[key: string]: string} = {`);
                for (let i = 0; i < queryParams.length; i++) {
                    let isLastParam = i === queryParams.length - 1;
                    this.code.push(`            ${queryParams[i].name}: encodeURIComponent('' + ${queryParams[i].name})${isLastParam ? '' : ','}`);
                }
                this.code.push(`        };`)
            }

            let bodyParam = (operation.parameters || []).find(p => p.type === 'body');
            let content = bodyParam ? `JSON.stringify(${bodyParam.name})` : `''`;
            let returnType = getReturnType(operation);
            this.code.push(
                `        const content: string = ${content};`,
                `        return this.http.request(buildServiceUrl(this.baseUrl, resourceUrl, ${hasQueryParams ? 'queryParams' : 'undefined'}), {`,
                `            body: content,`,
                `            method: '${operation.verb}',`,
                `            headers: new Headers({`,
                `                'Content-Type': 'application/json; charset=UTF-8'`,
                `            })`,
                `        }).map((response: Response) => {`,
                `            return this.__process_${transformedOperationName}(response);`,
                `        }).catch((response: any, caught: any) => {`,
                `            return handleError<${returnType}>(response, this.__process_${transformedOperationName});`,
                `        });`
            );

            this.code.push(`    }`);

            this.code.push('');

            this.code.push(
                `    private __process_${transformedOperationName}(response: Response): ${returnType} {`,
                `        const data: string = response.text();`,
                `        const status: number = response.status;`
            );
            // If no responses declared. Should never be reached.
            if (!operation.responses) {
                this.code.push(
                    `        if (status >= 200 && status < 300) {`,
                    `            return undefined;`,
                    `        }`
                );
            }

            let noDataTypeStatuses = [];
            for (let statusKey in operation.responses) {
                let dataType = operation.responses[statusKey].dataType;
                if (dataType) {
                    let dataTypeName = getDataType(dataType);
                    this.code.push(
                        `        if (status === ${statusKey}) {`,
                        `            let result: ${dataTypeName} = data === '' ? undefined`,
                        `                : <${dataTypeName}>JSON.parse(data)`,
                        `            return result;`,
                        `        }`
                    );
                } else {
                    noDataTypeStatuses.push(statusKey);
                }
            }
            if (noDataTypeStatuses.length > 0) {
                let condition = noDataTypeStatuses.map(s => `status === ${s}`).join(' || ');
                this.code.push(
                    `        if (${condition}) {`,
                    `            return undefined;`,
                    `        }`
                );
            }
            this.code.push(
                `        throw 'error_no_callback_for_status' + status;`,
                `    }`
            );

            this.code.push('');
        }

        this.code.push(`}`);
    }

    generateBuildUrlFunction() {
        this.code.push(
            `function buildServiceUrl(baseUrl: string, resourceUrl: string, queryParams?: {[name: string]: string}): string {`,
            `    let url: string = baseUrl;`,
            `    let baseUrlSlash: boolean = url[url.length - 1] === '/';`,
            `    let resourceUrlSlash: boolean = resourceUrl[0] === '/';`,
            `    if (!baseUrlSlash && !resourceUrlSlash) {`,
            `        url += '/';`,
            `    } else if (baseUrlSlash && resourceUrlSlash) {`,
            `        url = url.substr(0, url.length - 1);`,
            `    }`,
            `    url += resourceUrl;`,
            ``,
            `    if (queryParams) {`,
            `        let isFirst: boolean = true;`,
            `        for (let p in queryParams) {`,
            `            if (queryParams.hasOwnProperty(p) && queryParams[p]) {`,
            `                let separator: string = isFirst ? '?' : '&';`,
            `                url += separator + p + '=' + queryParams[p];`,
            `                isFirst = false;`,
            `            }`,
            `        }`,
            `    }`,
            ``,
            `    return url;`,
            `}`
        );
    }

    generateHandleErrorFunction() {
        this.code.push(
            `function handleError<T>(response: any, processor: (response: Response) => T): Observable<T> {`,
            `    if (response instanceof Response) {`,
            `        try {`,
            `            return Observable.of(processor(response));`,
            `        } catch (e) {`,
            `            return <Observable<T>><any>Observable.throw(e);`,
            `        }`,
            `    }`,
            `    return <Observable<T>><any>Observable.throw(response);`,
            `}`
        );
    }

    generateModels() {
        for (let modelName in this.definition.models) {
            let model = this.definition.models[modelName];
            this.code.push(`export interface ${modelName} {`);

            for (let propertyName in model) {
                let property = model[propertyName];
                this.code.push(`    ${propertyName}${property.required ? '?' : ''}: ${getDataType(property, propertyName)};`);
            }

            this.code.push('}');
        }
    }

    generateEnums() {
        for (let serviceName in this.definition.services) {
            let service = this.definition.services[serviceName];
            for (let operationName in service) {
                let operation = service[operationName];
                for (let i = 0; i < operation.parameters.length; i++) {
                    let dataType = operation.parameters[i].dataType;
                    if (dataType.primitive && dataType.primitive === 'string' && dataType.subType === 'enum') {
                        let enumTypeName = _.upperFirst(_.camelCase(operation.parameters[i].name));
                        this.code.push(`export type ${enumTypeName}Enum = '${dataType.enumValues.join('\'|\'')}';`)
                    }
                }
            }
        }
    }
}
